name: Production

# Exclude the workflow to run on changes to the helm chart
on:
  push:
    branches:
      - Deploying
jobs:
  run-DevOps_Project:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Configure kubectl
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      - name: install EKS
        run: |
          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin/
          eksctl version
          pwd
      - name: Check if EKS cluster exists
        id: check-eks
        run: |
          
            if aws eks describe-cluster --name demo-cluster --region us-east-1; then
               echo "exists=true" >> $GITHUB_OUTPUT
               aws eks update-kubeconfig --region us-east-1 --name demo-cluster

            else
               echo "exists=false" >> $GITHUB_OUTPUT
               eksctl create cluster --name demo-cluster --region us-east-1 
            
          
             fi
      
      - name: list cluster
        run: aws eks list-clusters
      - name: download policy 
        run: |
          curl -O https://raw.githubusercontent.com/kubernetes-sigs/aws-ebs-csi-driver/master/docs/example-iam-policy.json
          POLICY_NAME="AmazonEKS_EBS_CSI_Policy"
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          POLICY_ARN="arn:aws:iam::$ACCOUNT_ID:policy/$POLICY_NAME"
          if aws iam get-policy --policy-arn $POLICY_ARN >/dev/null 2>&1; then
            echo "policy exist"
          else
            echo "policy not exist , kindly create"
            aws iam create-policy \
              --policy-name $POLICY_NAME \
              --policy-document file://example-iam-policy.json
          fi
      - name: attach policy
        run: |
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          POLICY_ARN="arn:aws:iam::$ACCOUNT_ID:policy/AmazonEKS_EBS_CSI_Policy"
          ROLE_NAME=$(aws iam list-roles \
            --query "Roles[?contains(RoleName, 'NodeInstanceRole')].RoleName" \
            --output text)
          echo $ROLE_NAME
          aws iam attach-role-policy \
            --role-name $ROLE_NAME \
            --policy-arn $POLICY_ARN
      - name: download aws-ebs-csi-driver 
        run: |
          eksctl create addon --name aws-ebs-csi-driver --cluster demo-cluster --region us-east-1
      - name: get the addon
        run: eksctl get addon --cluster demo-cluster --region us-east-1
      - name: get the pods
        run: kubectl get pods -n kube-system | grep ebs
      

      
      - name: waiting pod aws-ebs-csi-driver 
        run: |
          kubectl wait --for=condition=Ready pod \
            -l app.kubernetes.io/name=aws-ebs-csi-driver \
            -n kube-system --timeout=300s



        


      - name: Verify EBS CSI Status
        run: kubectl get pods -n kube-system | grep ebs

      # - name: restart addons 
      #   run: kubectl rollout restart deployment ebs-csi-controller -n kube-system
      - name: get the ebsi pods
        run: |
           
           kubectl get pods -n kube-system | grep ebs
      
         


      - name: create users in db
        run: |
          ls -la kubernetes/authentication/mysql
          kubectl get secret mysql-secret >/dev/null 2>&1 || { \
           cd kubernetes/authentication/mysql; \
           kubectl create secret generic mysql-secret \
              --from-literal=root-password='secure-root-pw' \
              --from-literal=auth-password='my-secret-pw' \
              --from-literal=secret-key='xco0sr0fh4e52x03g9mv';  \
               }
      - name: deploy db
        run: |
          
          kubectl apply -f ./kubernetes/authentication/mysql/ebs.yaml
          kubectl apply -f ./kubernetes/authentication/mysql/headless-service.yaml
          kubectl apply -f ./kubernetes/authentication/mysql/statefulset.yaml
          kubectl get pods -n kube-system | grep ebs
          
      - name: waiting for database pod ready 
        run: kubectl wait --for=condition=ready pod -l app=mysql --timeout=90s

      - name: getting pods and svc
        run: |
          
          kubectl get pods
          kubectl get svc
          
   
      - name: create data on Data_Base
        run: kubectl apply -f ./kubernetes/authentication/mysql/init-job.yaml
      - name: create Svc account on database 
        run: |
          kubectl exec mysql-0 -- sh -c "
          mysql -u authuser -pmy-secret-pw <<EOF
          SHOW DATABASES;
          USE weatherapp;
          SHOW TABLES;
          EOF
          "

      
          
      - name: connect on db
        run: |
         kubectl apply -f ./kubernetes/authentication/service.yaml 
         kubectl apply -f ./kubernetes/authentication/deployment.yaml
      
      - name: create secret in weather service
        run: |
          kubectl get secret weather >/dev/null 2>&1 || { \
           cd kubernetes/weather; \
              kubectl create secret generic weather \
                --from-literal=apikey=dd14af1bc5msh2f2906c42d09a2fp1632d8jsnef251bbd6cc6;\ 
                }
      - name: deploy weather service
        run: |
          kubectl apply -f ./kubernetes/weather/service.yaml
          kubectl apply -f ./kubernetes/weather/deployment.yaml
      - name: create certificate in UI service
        run: |
         kubectl get secret weatherapp-ui-tls >/dev/null 2>&1 || { \
          cd kubernetes/ui; \
             openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout tls.key -out tls.crt -subj "/CN=weatherapp.local/O=weatherapp"
             kubectl create secret tls weatherapp-ui-tls --cert=tls.crt --key=tls.key;\ 
             }
      - name: deploy UI service
        run: |
          

          kubectl apply -f ./kubernetes/ui/service.yaml
          kubectl apply -f ./kubernetes/ui/deployment.yaml
          kubectl apply -f ./kubernetes/ui/ingress.yaml
      - name: Run EKS Cluster
        run:  |
          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin/
          kubectl get pods -n ingress-nginx
          pwd
          eksctl version
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.1/deploy/static/provider/aws/deploy.yaml 
          kubectl get ing
      
      - name: waiting ingress controller created
        run: |
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=ingress-nginx -n ingress-nginx --timeout=180s
          kubectl get ing
          kubectl get pods -n ingress-nginx



      - name: Get Load Balancer DNS name
        id: get_dns
        run: |
          ELB_DNS=$(kubectl get ing weatherapp-ui-ingress -n default -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "ELB_DNS=$ELB_DNS" >> $GITHUB_ENV
          echo "DNS Address: $ELB_DNS"
      - name: list nodes-ips and ingress-ips
        run: |
          kubectl get nodes -o wide
          kubectl get ing
          nslookup $ELB_DNS
          kubectl get svc
          kubectl get pods
          
     